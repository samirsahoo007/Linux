Ref: http://www.andrewhavens.com/posts/20/beginners-guide-to-creating-a-rest-api/
8 http methods
Get, Post, Put, Delete,
Options, head, trace, connect

http://example.com/view_widgets 				# Get
http://example.com/create_new_widget?name=Widgetizer		# Post
http://example.com/update_widget?id=123&name=Foo 		# Put
http://example.com/delete_widget?id=123			# Delete

Difference between Put and Post?
Post is used to create
Put is used to create and update
PUT vs POST : An Example
Let’s say we are designing a network application. Let’s list down few URIs and their purpose to get better understanding when to use POST and when to use PUT operations.
GET 	/device-management/devices : Get all devices
POST 	/device-management/devices : Create a new device

GET 	/device-management/devices/{id} : Get the device information identified by "id"
PUT 	/device-management/devices/{id} : Update the device information identified by "id"
DELETE	/device-management/devices/{id} : Delete device by "id"

PUT /user/12345 HTTP/1.1  <-- create the user providing the id 12345
Host: mydomain.com

GET /user/12345 HTTP/1.1  <-- return that user
Host: mydomain.com
Otherwise, use POST to initially create the object, and PUT to update the object:
POST /user HTTP/1.1   <--- create the user, server returns 12345
Host: mydomain.com

PUT /user/12345 HTTP/1.1  <--- update the user
Host: mydomain.com


In short:
PUT is idempotent, where the resource state will be the same if the same operation is executed one time or multiple times.
POST is non-idempotent, where the resource state may become different if the operation is executed multiple times as compared to executing a single time.
Analogy with database query
PUT You can think of similar to "UPDATE STUDENT SET address = "abc" where id="123";
POST You can think of something like "INSERT INTO STUDENT(name, address) VALUES ("abc", "xyzzz");
Student Id is auto generated.
With PUT, if the same query is executed multiple times or one time, the STUDENT table state remains the same.
In case of POST, if the same query is executed multiple times then multiple Student records get created in the database and the database state changes on each execution of an "INSERT" query.
NOTE: PUT needs a resource location (already-resource) on which update needs to happen, whereas POST doesn't require that. Therefore intuitively POST is meant for creation of a new resource, whereas PUT is needed for updating the already existing resource.
Some may come up with that updates can be performed with POST. There is no hard rule which one to use for updates or which one to use for create. Again these are conventions, and intuitively I'm inclined with the above mentioned reasoning and follow it.

Most of the time, you will use them like this:
•	POST a resource into a collection
•	PUT a resource identified by collection/:id
For example:
•	POST /items
•	PUT /items/1234

The semantics are supposed be different, in that "PUT", like "GET" is supposed to be idempotent -- meaning, you can the same exact PUT request multiple times and the result will be as if you executed it only once.
For example, when you want to create a new stream, you can PUT it to some URL. But when you want to POST a message to an existing stream, you POST to its URL.

In a very simple way I'm taking the example of the Facebook timeline.
Case 1: When you post something on your timeline, it's a fresh new entry. So in this case they use the POST method because the POST method is non-idempotent.
Case 2: If your friend comment on your post the first time, that also will create a new entry in the database so the POST method used.
Case 3: If your friend edits his comment, in this case, they had a comment id, so they will update an existing comment instead of creating a new entry in the database. Therefore for this type of operation use the PUT method because it is idempotent.*
In a single line, use POST to add a new entry in the database and PUT to update something in the database.
 













What is an API?
The term API stands for Application Programming Interface. The term can be used to describe the features of a library, or how to interact with it. Your favorite library may have "API Documentation" which documents which functions are available, how you call them, which arguments are required, etc.
However, these days, when people refer to an API they are most likely referring to an HTTP API, which can be a way of sharing application data over the internet. For example, Twitter has an API that allows you to request tweets in a format that makes it easy to import into your own application. This is the true power of HTTP APIs, being able to "mashup" data from multiple applications into your own hybrid application, or create an application which enhances the experience of using someone else's application.
For example, let's say we have an application that allows you to view, create, edit, and delete widgets. We could create an HTTP API that allows you to perform these functions:
http://example.com/view_widgets
http://example.com/create_new_widget?name=Widgetizer
http://example.com/update_widget?id=123&name=Foo
http://example.com/delete_widget?id=123
A problem has started to arise when everyone starts implementing their own APIs. Without a standard way of naming URLs, you always have to refer to the documentation to understand how the API works. One API might have a URL like /view_widgets whereas another API might use /widgets/all.
Don't worry, REST comes to rescue us from this mess.
What is REST?
REST stands for Representational State Transfer. This is a term invented by Roy Fielding to describe a standard way of creating HTTP APIs. He noticed that the four common actions (view, create, edit, and delete) map directly to HTTP verbs that are already implemented: GET, POST, PUT, DELETE.
If you're new to HTTP, you may not be familiar with some of these verbs. So let me give a brief rundown on HTTP methods.
HTTP methods
There are technically 8 different HTTP methods:
GET
POST
PUT
DELETE
OPTIONS
HEAD
TRACE
CONNECT
Most of the time, when you're clicking around in your browser, you are only ever using the GET HTTP method. GET is used when you are "getting" a resource from the internet. When you submit a form, you are usually using the POST method to "post data" back to the website. As for the other methods, some browsers don't even implement them all. However, for our uses, that doesn't matter. What matters is that we have a bunch of "verbs" to choose from which help to describe the actions we are taking. We will be using client libraries which already know how to use the different HTTP methods.
Examples of REST
Let's look at a few examples of what makes an API "RESTful". Using our widgets example again...
If we wanted to view all widgets, the URL would look like this:
GET http://example.com/widgets
Create a new widget by posting the data:
POST http://example.com/widgets
Data:
    name = Foobar
To view a single widget we "get" it by specifying that widget's id:
GET http://example.com/widgets/123
Update that widget by "putting" the new data:
PUT http://example.com/widgets/123
Data:
    name = New name
    color = blue
Delete that widget:
DELETE http://example.com/widgets/123
Anatomy of a REST URL
You might have noticed from the previous examples that REST URLs use a consistent naming scheme. When you are interacting with an API, you are almost always manipulating some sort of object. In our examples, this is a Widget. In REST terminology, this is called a Resource. The first part of the URL is always the plural form of the resource:
/widgets
This is always used when referring to this collection of resources ("list all" and "add one" actions). When you are working with a specific resource, you add the ID to the URL.
/widgets/123
This URL is used when you want to "view", "edit", or "delete" the particular resource.
Nested Resources
Let's say our widgets have many users associated with them. What would this URL structure look like?
List all:
GET /widgets/123/users
Add one:
POST /widgets/123/users
Data:
    name = Andrew
Nested resources are perfectly acceptable in URLs. However, it's not a best practice to go more than two levels deep. It's not necessary because you can simply refer to those nested resources by ID rather than nesting them within their parents. For example:
/widgets/123/users/456/sports/789
...can be referenced as:
/users/456/sports/789
...or even:
/sports/789
HTTP Status Codes
Another important part of REST is responding with the correct status code for the type of request that was made. If you're new to HTTP status codes, heres a quick summary. When you make an HTTP request, the server will respond with a code which corresponds to whether or not the request was successful and how the client should proceed. There are four different levels of codes:
•	2xx = Success
•	3xx = Redirect
•	4xx = User error
•	5xx = Server error
Here's a list of the most important status codes:
Success codes:
•	200 - OK (the default)
•	201 - Created
•	202 - Accepted (often used for delete requests)
•	204 NO CONTENT − when response body is empty. For example, a DELETE request.

Redirect codes:
304 NOT MODIFIED − used to reduce network bandwidth usage in case of conditional GET requests. Response body should be empty. Headers should have date, location, etc.
User error codes:
•	400 - Bad Request (generic user error/bad data)
•	401 - Unauthorized (this area requires you to log in)
•	403 FORBIDDEN − states that the user is not having access to the method being used. For example, Delete access without admin rights.
•	404 - Not Found (bad URL)
•	405 - Method Not Allowed (wrong HTTP method)
•	409 - Conflict (i.e. trying to create the same resource with a PUT request)
•	500 INTERNAL SERVER ERROR − states that the server has thrown some exception while executing the method.
API response formats
When you make an HTTP request, you can request the format that you want to receive. For example, making a request for a webpage, you want the format to be in HTML, or if you are downloading an image, the format returned should be an image. However, it's the server's responsibility to respond in the format that was requested.
JSON has quickly become the format of choice for REST APIs. It has a lightweight, readable syntax that can be easily manipulated. So when a user of our API makes a request and specifies JSON as the format they would prefer:
GET /widgets
Accept: application/json
...our API will return an array of widgets formatted as JSON:
[
  {
    id: 123,
    name: 'Simple Widget'
  },
  {
    id: 456,
    name: 'My other widget'
  }
]
If the user requests a format that we haven't implemented, what do we do? You can throw some type of error, but I would recommend enforcing JSON as your standard response format. It's the format that your developers will want to use. No reason to support other formats unless you already have an API which needs to be supported.
Building a REST API
Actually building a REST API is mostly outside the scope of this tutorial since it is language specific, but I will give a brief example in Ruby using a library called Sinatra:
require 'sinatra'
require 'JSON'
require 'widget' # our imaginary widget model

# list all
get '/widgets' do
  Widget.all.to_json
end

# view one
get '/widgets/:id' do
  widget = Widget.find(params[:id])
  return status 404 if widget.nil?
  widget.to_json
end

# create
post '/widgets' do
  widget = Widget.new(params['widget'])
  widget.save
  status 201
end

# update
put '/widgets/:id' do
  widget = Widget.find(params[:id])
  return status 404 if widget.nil?
  widget.update(params[:widget])
  widget.save
  status 202
end

delete '/widgets/:id' do
  widget = Widget.find(params[:id])
  return status 404 if widget.nil?
  widget.delete
  status 202
end
API authentication
In normal web applications, handling authentication is usually handled by accepting a username and password, and saving the user ID in the session. The user's browser saves a cookie with ID of the session. When the user visits a page on the site that requires authentication, the browser sends the cookie, the app looks up the session by the ID (if it hasn't expired), and since the user ID was saved in the session, the user is allowed to view the page.
With an API, using sessions to keep track of users is not necessarily the best approach. Sometimes, your users may want to access the API directly, other times the user may way to authorize another application to access the API on their behalf.
The solution to this is to use token based authentication. The user logs in with their username and password and the application responds with a unique token that the user can use for future requests. This token can be passed onto the application so that the user can revoke that token later if they choose to deny that application further access.
There is a standard way of doing this that has become very popular. It's called OAuth. Specifically, version 2 of the OAuth standard. There are a lot of great resources online for implementing OAuth so I would say that is outside the scope of this tutorial. If you are using Ruby, there are some great libraries that handle most of the work for you, like OmniAuth.
Hopefully, I've filled in enough blanks for you to get started. If you still have questions, you may find this tutorial helpful.
Feel free to post any questions or criticisms in the comments.
Ref: http://www.andrewhavens.com/posts/20/beginners-guide-to-creating-a-rest-api/



To start with, the MarkLogic REST API assumes three job roles for individuals:
1.	The developer. This person does the day to day programming against REST endpoints. They're a pro with .NET, Ruby, Python, or some other language, and the REST API documentation (Developers Guide and REST Client API reference) are the main exposure they have to MarkLogic. 
2.	The developer admin. This person controls MarkLogic administrative settings and configuration that affect the REST API's behavior. For example, they adjust current query settings, any stored transformations or extensions which may be called, and index settings. They do this via REST endpoints separate from those available to the regular developer. They do not access or administer MarkLogic outside of these endpoints. 
3.	The database admin. This person installs MarkLogic, creates users, sets up databases and REST servers, and manages and monitors them. They're the classic IT database administrator, often not a programmer. 
In some cases, a single individual may have more than one of these roles. For example, if you're running MarkLogic on your own laptop, you'll assume all of these roles on day one.
What is REST?

REST stands for REpresentational State Transfer. REST is a web standards based architecture and uses HTTP Protocol for data communication. It revolves around resources where every component is a
resource and a resource is accessed by a common interface using HTTP standard methods. REST was first introduced by Roy Fielding in year 2000.

In REST architecture, a REST Server simply provides access to resources and the REST client accesses and presents the resources. Here each resource is identified by URIs/ Global IDs.
REST uses various representations to represent a resource like Text, JSON and XML. JSON is now the most popular format being used in Web Services.

HTTP Methods
The following HTTP methods are most commonly used in a REST based architecture.

GET − Provides a read only access to a resource.
POST − Used to update an existing resource or create a new resource.
PUT − Used to create a new resource.
DELETE − Used to remove a resource.
OPTIONS − Used to get the supported operations on a resource.


RESTFul Web Services

A web service is a collection of open protocols and standards used for exchanging data between applications or systems. Software applications written in various programming languages and
running on various platforms can use web services to exchange data over computer networks like the Internet in a manner similar to inter-process communication on a single computer.

This interoperability (e.g., between Java and Python, or Windows and Linux applications) is due to the use of open standards.

A RESTful web service usually defines a URI (Uniform Resource Identifier), which is a service that provides resource representation such as JSON and a set of HTTP Methods.

Creating RESTFul Web Service

Let's create a web service called User Management with the following functionalities −

Sr.No.
HTTP Method
URI
Operation
Operation Type

1 GET /UserService/users Get list of users Read Only
2 GET /UserService/users/1 Get User with Id 1 Read Only
3 PUT /UserService/users/2 Insert User with Id 2 Idempotent
4 POST /UserService/users/2 Update User with Id 2 N/A
5 DELETE /UserService/users/1 Delete User with Id 1 Idempotent
6 OPTIONS /UserService/users List the supported operations in web service Read Only
What is a Resource?

REST architecture treats every content as a resource. These resources can be Text Files, Html Pages, Images, Videos or Dynamic Business Data. REST Server simply provides access to resources and REST client accesses and modifies the resources. Here each resource is identified by URIs/ Global IDs. REST uses various representations to represent a resource where Text, JSON, XML. The most popular representations of resources are XML and JSON.

Representation of Resources

A resource in REST is a similar Object in Object Oriented Programming or is like an Entity in a Database. Once a resource is identified then its representation is to be decided using a standard
format so that the server can send the resource in the above said format and client can understand the same format.

For example, in RESTful Web Services - First Application chapter, a user is a resource which is represented using the following XML format −
<user>
   <id>1</id>
   <name>Mahesh</name>
   <profession>Teacher</profession>
</user>

The same resource can be represented in JSON format as follows −
{
   "id":1,
   "name":"Mahesh",
   "profession":"Teacher"
}

Good Resources Representation

REST does not impose any restriction on the format of a resource representation.
However, at present most of the web services are representing resources using either XML or JSON format. There are plenty of libraries and tools available to understand, parse, and modify XML and JSON data.

Following are some important points to be considered while designing a representation format of a resource in RESTful Web Services.

Understandability − Both the Server and the Client should be able to understand and utilize the representation format of the resource.
Completeness − Format should be able to represent a resource completely. For example, a resource can contain another resource. Format should be able to represent simple as well as complex structures of resources.
Linkablity − A resource can have a linkage to another resource, a format should be able to handle such situations.

Let us start writing the actual RESTful web services with Jersey Framework. Before you start writing your first example using the Jersey Framework, you have to make sure that you have setup your Jersey environment properly as explained in the RESTful Web Services - Environment Setup chapter. Here, I am also assuming that you have a little working knowledge of Eclipse IDE.
So, let us proceed to write a simple Jersey Application which will expose a web service method to display the list of users.
Creating a Java Project
The first step is to create a Dynamic Web Project using Eclipse IDE. Follow the option File → New → Project and finally select the Dynamic Web Project wizard from the wizard list. Now name your project as UserManagement using the wizard window as shown in the following screenshot −
 
Once your project is created successfully, you will have the following content in your Project Explorer −
 
Adding the Required Libraries
As a second step let us add Jersey Framework and its dependencies (libraries) in our project. Copy all jars from following directories of download jersey zip folder in WEB-INF/lib directory of the project.
•	\jaxrs-ri-2.17\jaxrs-ri\api
•	\jaxrs-ri-2.17\jaxrs-ri\ext
•	\jaxrs-ri-2.17\jaxrs-ri\lib
Now, right click on your project name UserManagement and then follow the option available in context menu − Build Path → Configure Build Path to display the Java Build Path window.
Now use Add JARs button available under Libraries tab to add the JARs present in WEBINF/lib directory.
Creating the Source Files
Now let us create the actual source files under the UserManagement project. First we need to create a package called com.tutorialspoint. To do this, right click on src in package explorer section and follow the option − New → Package.
Next we will create UserService.java, User.java,UserDao.java files under the com.tutorialspoint package.
User.java
package com.tutorialspoint;  

import java.io.Serializable;  
import javax.xml.bind.annotation.XmlElement; 
import javax.xml.bind.annotation.XmlRootElement; 
@XmlRootElement(name = "user") 

public class User implements Serializable {  
   private static final long serialVersionUID = 1L; 
   private int id; 
   private String name; 
   private String profession;  
   public User(){} 
    
   public User(int id, String name, String profession){  
      this.id = id; 
      this.name = name; 
      this.profession = profession; 
   }  
   public int getId() { 
      return id; 
   }  
   @XmlElement 
   public void setId(int id) { 
      this.id = id; 
   } 
   public String getName() { 
      return name; 
   } 
   @XmlElement
   public void setName(String name) { 
      this.name = name; 
   } 
   public String getProfession() { 
      return profession; 
   } 
   @XmlElement 
   public void setProfession(String profession) { 
      this.profession = profession; 
   }   
} 
UserDao.java
package com.tutorialspoint;  

import java.io.File; 
import java.io.FileInputStream; 
import java.io.FileNotFoundException;  
import java.io.FileOutputStream; 
import java.io.IOException; 
import java.io.ObjectInputStream; 
import java.io.ObjectOutputStream; 
import java.util.ArrayList; 
import java.util.List;  

public class UserDao { 
   public List<User> getAllUsers(){ 
      
      List<User> userList = null; 
      try { 
         File file = new File("Users.dat"); 
         if (!file.exists()) { 
            User user = new User(1, "Mahesh", "Teacher"); 
            userList = new ArrayList<User>(); 
            userList.add(user); 
            saveUserList(userList); 
         } 
         else{ 
            FileInputStream fis = new FileInputStream(file); 
            ObjectInputStream ois = new ObjectInputStream(fis); 
            userList = (List<User>) ois.readObject(); 
            ois.close(); 
         } 
      } catch (IOException e) { 
         e.printStackTrace(); 
      } catch (ClassNotFoundException e) { 
         e.printStackTrace(); 
      }   
      return userList; 
   } 
   private void saveUserList(List<User> userList){ 
      try { 
         File file = new File("Users.dat"); 
         FileOutputStream fos;  
         fos = new FileOutputStream(file); 
         ObjectOutputStream oos = new ObjectOutputStream(fos); 
         oos.writeObject(userList); 
         oos.close(); 
      } catch (FileNotFoundException e) { 
         e.printStackTrace(); 
      } catch (IOException e) { 
         e.printStackTrace(); 
      } 
   }    
}
UserService.java
package com.tutorialspoint;  

import java.util.List; 
import javax.ws.rs.GET; 
import javax.ws.rs.Path; 
import javax.ws.rs.Produces; 
import javax.ws.rs.core.MediaType;  
@Path("/UserService") 

public class UserService {  
   UserDao userDao = new UserDao();  
   @GET 
   @Path("/users") 
   @Produces(MediaType.APPLICATION_XML) 
   public List<User> getUsers(){ 
      return userDao.getAllUsers(); 
   }  
}
There are two important points to be noted about the main program,
UserService.java
•	The first step is to specify a path for the web service using @Path annotation to the UserService.
•	The second step is to specify a path for the particular web service method using @Path annotation to method of UserService.
Creating the Web.xml configuration File
You need to create a Web xml Configuration file which is an XML file and is used to specify Jersey framework servlet for our application.
web.xml
<?xml version = "1.0" encoding = "UTF-8"?> 
<web-app xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"  
   xmlns = "http://java.sun.com/xml/ns/javaee"  
   xsi:schemaLocation="http://java.sun.com/xml/ns/javaee  
   http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"  
   id = "WebApp_ID" version = "3.0"> 
   <display-name>User Management</display-name> 
   <servlet> 
      <servlet-name>Jersey RESTful Application</servlet-name> 
      <servlet-class>org.glassfish.jersey.servlet.ServletContainer</servlet-class> 
      <init-param> 
         <param-name>jersey.config.server.provider.packages</param-name> 
         <param-value>com.tutorialspoint</param-value> 
      </init-param> 
   </servlet> 
   <servlet-mapping> 
      <servlet-name>Jersey RESTful Application</servlet-name> 
      <url-pattern>/rest/*</url-pattern> 
   </servlet-mapping>   
</web-app>
Deploying the Program
Once you are done with creating source and web configuration files, you are ready for this step which is compiling and running your program. To do this, using Eclipse, export your application as a war file and deploy the same in tomcat.
To create a WAR file using eclipse, follow the option File → export → Web → War File and finally select project UserManagement and destination folder. To deploy a war file in Tomcat, place the UserManagement.war in the Tomcat Installation Directory → webapps directory and start the Tomcat.
Running the Program
We are using Postman, a Chrome extension, to test our webservices.
Make a request to UserManagement to get list of all the users. Put http://localhost:8080/UserManagement/rest/UserService/users in POSTMAN with GET request and see the following result.
 
Congratulations, you have created your first RESTful Application successfully.
RESTful Web Services make use of HTTP protocols as a medium of communication between client and server. A client sends a message in form of a HTTP Request and the server responds in the form of an HTTP Response. This technique is termed as Messaging. These messages contain message data and metadata i.e. information about message itself. Let us have a look on the HTTP Request and HTTP Response messages for HTTP 1.1.
HTTP Request
 
An HTTP Request has five major parts −
•	Verb − Indicates the HTTP methods such as GET, POST, DELETE, PUT, etc.
•	URI − Uniform Resource Identifier (URI) to identify the resource on the server.
•	HTTP Version − Indicates the HTTP version. For example, HTTP v1.1.
•	Request Header − Contains metadata for the HTTP Request message as key-value pairs. For example, client (or browser) type, format supported by the client, format of the message body, cache settings, etc.
•	Request Body − Message content or Resource representation.
HTTP Response
 
An HTTP Response has four major parts −
•	Status/Response Code − Indicates the Server status for the requested resource. For example, 404 means resource not found and 200 means response is ok.
•	HTTP Version − Indicates the HTTP version. For example HTTP v1.1.
•	Response Header − Contains metadata for the HTTP Response message as keyvalue pairs. For example, content length, content type, response date, server type, etc.
•	Response Body − Response message content or Resource representation.
Example
As we have explained in the RESTful Web Services - First Application chapter, let us put http://localhost:8080/UserManagement/rest/UserService/users in the POSTMAN with a GET request. If you click on the Preview button which is near the send button of Postman and then click on the Send button, you may see the following output.
 
Here you can see, the browser sent a GET request and received a response body as XML.
Addressing refers to locating a resource or multiple resources lying on the server. It is analogous to locate a postal address of a person.
Each resource in REST architecture is identified by its URI (Uniform Resource Identifier). A URI is of the following format −
<protocol>://<service-name>/<ResourceType>/<ResourceID>
Purpose of an URI is to locate a resource(s) on the server hosting the web service. Another important attribute of a request is VERB which identifies the operation to be performed on the resource. For example, in RESTful Web Services - First Application chapter, the URI is http://localhost:8080/UserManagement/rest/UserService/users and the VERB is GET.
Constructing a Standard URI
The following are important points to be considered while designing a URI −
•	Use Plural Noun − Use plural noun to define resources. For example, we've used users to identify users as a resource.
•	Avoid using spaces − Use underscore (_) or hyphen (-) when using a long resource name. For example, use authorized_users instead of authorized%20users.
•	Use lowercase letters − Although URI is case-insensitive, it is a good practice to keep the url in lower case letters only.
•	Maintain Backward Compatibility − As Web Service is a public service, a URI once made public should always be available. In case, URI gets updated, redirect the older URI to a new URI using the HTTP Status code, 300.
•	Use HTTP Verb − Always use HTTP Verb like GET, PUT and DELETE to do the operations on the resource. It is not good to use operations name in the URI.
Example
Following is an example of a poor URI to fetch a user.
http://localhost:8080/UserManagement/rest/UserService/getUser/1 
Following is an example of a good URI to fetch a user.
http://localhost:8080/UserManagement/rest/UserService/users/1

As we have discussed so far that RESTful web service makes heavy uses of HTTP verbs to determine the operation to be carried out on the specified resource(s). Following table states the examples of common use of HTTP Verbs.
HTTP Method	GET
URI	http://localhost:8080/UserManagement/rest/UserService/users
Operation	Get list of users
Operation Type	Read Only

HTTP Method	
GET
URI	http://localhost:8080/UserManagement/rest/UserService/users/1
Operation	Get user of Id 1
Operation Type	Read Only

HTTP Method	
POST
URI	http://localhost:8080/UserManagement/rest/UserService/users/2
Operation	Insert user with Id 2
Operation Type	Idempotent

HTTP Method	
PUT
URI	http://localhost:8080/UserManagement/rest/UserService/users/2
Operation	Update User with Id 2
Operation Type	N/A

HTTP Method	
DELETE
URI	http://localhost:8080/UserManagement/rest/UserService/users/1
Operation	Delete User with Id 1
Operation Type	Idempotent

HTTP Method	
OPTIONS
URI	http://localhost:8080/UserManagement/rest/UserService/users
Operation	List the supported operations in web service
Operation Type	Read Only

HTTP Method	
HEAD
URI	http://localhost:8080/UserManagement/rest/UserService/users
Operation	Returns only HTTP Header, no Body
Operation Type	Read Only
Here are important points to be considered:
•	GET operations are read only and are safe.
•	PUT and DELETE operations are idempotent means their result will always same no matter how many times these operations are invoked.
•	PUT and POST operation are nearly same with the difference lying only in the result where PUT operation is idempotent and POST operation can cause different result.


Example
Let's update Example created in RESTful Web Services - First Application tutorial to create a Web service which can perform CRUD (Create, Read, Update, Delete) operations. For simplicity, we've used a file I/O to replace Database operations.
Update UserService.java, User.java,UserDao.java files under the com.tutorialspoint package.
User.java
package com.tutorialspoint;

import java.io.Serializable;

import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
@XmlRootElement(name = "user")
public class User implements Serializable {

   private static final long serialVersionUID = 1L;
   private int id;
   private String name;
   private String profession;

   public User(){}

   public User(int id, String name, String profession){
      this.id = id;
      this.name = name;
      this.profession = profession;
   }

   public int getId() {
      return id;
   }
   @XmlElement
   public void setId(int id) {
      this.id = id;
   }
   public String getName() {
      return name;
   }
   @XmlElement
      public void setName(String name) {
      this.name = name;
   }
   public String getProfession() {
      return profession;
   }
   @XmlElement
   public void setProfession(String profession) {
      this.profession = profession;
   }	

   @Override
   public boolean equals(Object object){
      if(object == null){
         return false;
      }else if(!(object instanceof User)){
         return false;
      }else {
         User user = (User)object;
         if(id == user.getId()
            && name.equals(user.getName())
            && profession.equals(user.getProfession())
         ){
            return true;
         }			
      }
      return false;
   }	
}
UserDao.java
package com.tutorialspoint;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.List;

public class UserDao {
   public List<User> getAllUsers(){
      List<User> userList = null;
      try {
         File file = new File("Users.dat");
         if (!file.exists()) {
            User user = new User(1, "Mahesh", "Teacher");
            userList = new ArrayList<User>();
            userList.add(user);
            saveUserList(userList);		
         }
         else{
            FileInputStream fis = new FileInputStream(file);
            ObjectInputStream ois = new ObjectInputStream(fis);
            userList = (List<User>) ois.readObject();
            ois.close();
         }
      } catch (IOException e) {
         e.printStackTrace();
      } catch (ClassNotFoundException e) {
         e.printStackTrace();
      }		
      return userList;
   }

   public User getUser(int id){
      List<User> users = getAllUsers();

      for(User user: users){
         if(user.getId() == id){
            return user;
         }
      }
      return null;
   }

   public int addUser(User pUser){
      List<User> userList = getAllUsers();
      boolean userExists = false;
      for(User user: userList){
         if(user.getId() == pUser.getId()){
            userExists = true;
            break;
         }
      }		
      if(!userExists){
         userList.add(pUser);
         saveUserList(userList);
         return 1;
      }
      return 0;
   }

   public int updateUser(User pUser){
      List<User> userList = getAllUsers();

      for(User user: userList){
         if(user.getId() == pUser.getId()){
            int index = userList.indexOf(user);			
            userList.set(index, pUser);
            saveUserList(userList);
            return 1;
         }
      }		
      return 0;
   }

   public int deleteUser(int id){
      List<User> userList = getAllUsers();

      for(User user: userList){
         if(user.getId() == id){
            int index = userList.indexOf(user);			
            userList.remove(index);
            saveUserList(userList);
            return 1;   
         }
      }		
      return 0;
   }

   private void saveUserList(List<User> userList){
      try {
         File file = new File("Users.dat");
         FileOutputStream fos;

         fos = new FileOutputStream(file);

         ObjectOutputStream oos = new ObjectOutputStream(fos);		
         oos.writeObject(userList);
         oos.close();
      } catch (FileNotFoundException e) {
         e.printStackTrace();
      } catch (IOException e) {
         e.printStackTrace();
      }
   }
}
UserService.java
package com.tutorialspoint;

import java.io.IOException;
import java.util.List;

import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.FormParam;
import javax.ws.rs.GET;
import javax.ws.rs.OPTIONS;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;

@Path("/UserService")
public class UserService {
	
   UserDao userDao = new UserDao();
   private static final String SUCCESS_RESULT="<result>success</result>";
   private static final String FAILURE_RESULT="<result>failure</result>";


   @GET
   @Path("/users")
   @Produces(MediaType.APPLICATION_XML)
   public List<User> getUsers(){
      return userDao.getAllUsers();
   }

   @GET
   @Path("/users/{userid}")
   @Produces(MediaType.APPLICATION_XML)
   public User getUser(@PathParam("userid") int userid){
      return userDao.getUser(userid);
   }

   @POST
   @Path("/users")
   @Produces(MediaType.APPLICATION_XML)
   @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
   public String createUser(@FormParam("id") int id,
      @FormParam("name") String name,
      @FormParam("profession") String profession,
      @Context HttpServletResponse servletResponse) throws IOException{
      User user = new User(id, name, profession);
      int result = userDao.addUser(user);
      if(result == 1){
         return SUCCESS_RESULT;
      }
      return FAILURE_RESULT;
   }

   @PUT
   @Path("/users")
   @Produces(MediaType.APPLICATION_XML)
   @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
   public String updateUser(@FormParam("id") int id,
      @FormParam("name") String name,
      @FormParam("profession") String profession,
      @Context HttpServletResponse servletResponse) throws IOException{
      User user = new User(id, name, profession);
      int result = userDao.updateUser(user);
      if(result == 1){
         return SUCCESS_RESULT;
      }
      return FAILURE_RESULT;
   }

   @DELETE
   @Path("/users/{userid}")
   @Produces(MediaType.APPLICATION_XML)
   public String deleteUser(@PathParam("userid") int userid){
      int result = userDao.deleteUser(userid);
      if(result == 1){
         return SUCCESS_RESULT;
      }
      return FAILURE_RESULT;
   }

   @OPTIONS
   @Path("/users")
   @Produces(MediaType.APPLICATION_XML)
   public String getSupportedOperations(){
      return "<operations>GET, PUT, POST, DELETE</operations>";
   }
}
Now using Eclipse, export your application as a war file and deploy the same in tomcat. To create WAR file using eclipse, follow the option File -> export -> Web > War File and finally select project UserManagement and destination folder. To deploy war file in Tomcat, place the UserManagement.war in Tomcat Installation Directory > webapps directory and start the Tomcat. 
Testing the Web Service
Jersey provides APIs to create a Web Service Client to test web services. We've created a sample test class WebServiceTester.java under the com.tutorialspoint package in the same project.
WebServiceTester.java
package com.tutorialspoint;

import java.util.List;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.Entity;
import javax.ws.rs.core.Form;
import javax.ws.rs.core.GenericType;
import javax.ws.rs.core.MediaType;

public class WebServiceTester  {

   private Client client;
   private String REST_SERVICE_URL = "http://localhost:8080/UserManagement/rest/UserService/users";
   private static final String SUCCESS_RESULT="<result>success</result>";
   private static final String PASS = "pass";
   private static final String FAIL = "fail";

   private void init(){
      this.client = ClientBuilder.newClient();
   }

   public static void main(String[] args){
      WebServiceTester tester = new WebServiceTester();
      //initialize the tester
      tester.init();
      //test get all users Web Service Method
      tester.testGetAllUsers();
      //test get user Web Service Method 
      tester.testGetUser();
      //test update user Web Service Method
      tester.testUpdateUser();
      //test add user Web Service Method
      tester.testAddUser();
      //test delete user Web Service Method
      tester.testDeleteUser();
   }
   //Test: Get list of all users
   //Test: Check if list is not empty
   private void testGetAllUsers(){
      GenericType<List<User>> list = new GenericType<List<User>>() {};
      List<User> users = client
         .target(REST_SERVICE_URL)
         .request(MediaType.APPLICATION_XML)
         .get(list);
      String result = PASS;
      if(users.isEmpty()){
         result = FAIL;
      }
      System.out.println("Test case name: testGetAllUsers, Result: " + result );
   }
   //Test: Get User of id 1
   //Test: Check if user is same as sample user
   private void testGetUser(){
      User sampleUser = new User();
      sampleUser.setId(1);

      User user = client
         .target(REST_SERVICE_URL)
         .path("/{userid}")
         .resolveTemplate("userid", 1)
         .request(MediaType.APPLICATION_XML)
         .get(User.class);
      String result = FAIL;
      if(sampleUser != null && sampleUser.getId() == user.getId()){
         result = PASS;
      }
      System.out.println("Test case name: testGetUser, Result: " + result );
   }
   //Test: Update User of id 1
   //Test: Check if result is success XML.
   private void testUpdateUser(){
      Form form = new Form();
      form.param("id", "1");
      form.param("name", "suresh");
      form.param("profession", "clerk");

      String callResult = client
         .target(REST_SERVICE_URL)
         .request(MediaType.APPLICATION_XML)
         .put(Entity.entity(form,
            MediaType.APPLICATION_FORM_URLENCODED_TYPE),
            String.class);
      String result = PASS;
      if(!SUCCESS_RESULT.equals(callResult)){
         result = FAIL;
      }

      System.out.println("Test case name: testUpdateUser, Result: " + result );
   }
   //Test: Add User of id 2
   //Test: Check if result is success XML.
   private void testAddUser(){
      Form form = new Form();
      form.param("id", "2");
      form.param("name", "naresh");
      form.param("profession", "clerk");

      String callResult = client
         .target(REST_SERVICE_URL)
         .request(MediaType.APPLICATION_XML)
         .post(Entity.entity(form,
            MediaType.APPLICATION_FORM_URLENCODED_TYPE),
            String.class);
   
      String result = PASS;
      if(!SUCCESS_RESULT.equals(callResult)){
         result = FAIL;
      }

      System.out.println("Test case name: testAddUser, Result: " + result );
   }
   //Test: Delete User of id 2
   //Test: Check if result is success XML.
   private void testDeleteUser(){
      String callResult = client
         .target(REST_SERVICE_URL)
         .path("/{userid}")
         .resolveTemplate("userid", 2)
         .request(MediaType.APPLICATION_XML)
         .delete(String.class);

      String result = PASS;
      if(!SUCCESS_RESULT.equals(callResult)){
         result = FAIL;
      }

      System.out.println("Test case name: testDeleteUser, Result: " + result );
   }
}
Now run the tester using Eclipse. Right click on the file, and follow the option Run as -> Java Application. You'll see the following result in Eclipse console:
Test case name: testGetAllUsers, Result: pass
Test case name: testGetUser, Result: pass
Test case name: testUpdateUser, Result: pass
Test case name: testAddUser, Result: pass
Test case name: testDeleteUser, Result: pass

As per the REST architecture, a RESTful Web Service should not keep a client state on the server. This restriction is called Statelessness. It is the responsibility of the client to pass its context to the server and then the server can store this context to process the client's further request. For example, session maintained by server is identified by session identifier passed by the client.
RESTful Web Services should adhere to this restriction. We have seen this in the RESTful Web Services - Methods chapter, that the web service methods are not storing any information from the client they are invoked from.
Consider the following URL −
https://localhost:8080/UserManagement/rest/UserService/users/1
If you hit the above url using your browser or using a java based client or using Postman, result will always be the User XML whose Id is 1 because the server does not store any information about the client.
<user> 
   <id>1</id> 
   <name>mahesh</name> 
   <profession>1</profession> 
</user>
Advantages of Statelessness
Following are the benefits of statelessness in RESTful Web Services −
•	Web services can treat each method request independently.
•	Web services need not maintain the client's previous interactions. It simplifies the application design.
•	As HTTP is itself a statelessness protocol, RESTful Web Services work seamlessly with the HTTP protocols.
Disadvantages of Statelessness
Following are the disadvantages of statelessness in RESTful Web Services −
•	Web services need to get extra information in each request and then interpret to get the client's state in case the client interactions are to be taken care of.
Caching refers to storing the server response in the client itself, so that a client need not make a server request for the same resource again and again. A server response should have information about how caching is to be done, so that a client caches the response for a time-period or never caches the server response.
Following are the headers which a server response can have in order to configure a client's caching −
Sr.No.	Header & Description
1	Date
Date and Time of the resource when it was created.
2	Last Modified
Date and Time of the resource when it was last modified.
3	Cache-Control
Primary header to control caching.
4	Expires
Expiration date and time of caching.
5	Age
Duration in seconds from when resource was fetched from the server.




Cache-Control Header
Following are the details of a Cache-Control header −
Sr.No.	Directive & Description
1	Public
Indicates that resource is cacheable by any component.
2	Private
Indicates that resource is cacheable only by the client and the server, no intermediary can cache the resource.
3	no-cache/no-store
Indicates that a resource is not cacheable.
4	max-age
Indicates the caching is valid up to max-age in seconds. After this, client has to make another request.
5	must-revalidate
Indication to server to revalidate resource if max-age has passed.
Best Practices
•	Always keep static contents like images, CSS, JavaScript cacheable, with expiration date of 2 to 3 days.
•	Never keep expiry date too high.
•	Dynamic content should be cached for a few hours only.
 
As RESTful Web Services work with HTTP URL Paths, it is very important to safeguard a RESTful Web Service in the same manner as a website is secured.
Following are the best practices to be adhered to while designing a RESTful Web Service −
•	Validation − Validate all inputs on the server. Protect your server against SQL or NoSQL injection attacks.
•	Session Based Authentication − Use session based authentication to authenticate a user whenever a request is made to a Web Service method.
•	No Sensitive Data in the URL − Never use username, password or session token in a URL, these values should be passed to Web Service via the POST method.
•	Restriction on Method Execution − Allow restricted use of methods like GET, POST and DELETE methods. The GET method should not be able to delete data.
•	Validate Malformed XML/JSON − Check for well-formed input passed to a web service method.
•	Throw generic Error Messages − A web service method should use HTTP error messages like 403 to show access forbidden, etc.

JAX-RS stands for JAVA API for RESTful Web Services. JAX-RS is a JAVA based programming language API and specification to provide support for created RESTful Web Services. Its 2.0 version was released on the 24th May 2013. JAX-RS uses annotations available from Java SE 5 to simplify the development of JAVA based web services creation and deployment. It also provides supports for creating clients for RESTful Web Services.
•	Specifications
•	Following are the most commonly used annotations to map a resource as a web service resource.
Sr.No.	Annotation & Description
1	@Path Relative path of the resource class/method.
2	@GET HTTP Get request, used to fetch resource.
3	@PUT HTTP PUT request, used to create resource.
4	@POST HTTP POST request, used to create/update resource.
5	@DELETE HTTP DELETE request, used to delete resource.
6	@HEAD HTTP HEAD request, used to get status of method availability.
7	@Produces States the HTTP Response generated by web service. For example, APPLICATION/XML, TEXT/HTML, APPLICATION/JSON etc.
8	
@Consumes States the HTTP Request type. For example, application/x-www-formurlencoded to accept form data in HTTP body during POST request.
9	@PathParam Binds the parameter passed to the method to a value in path.
10	@QueryParam Binds the parameter passed to method to a query parameter in the path.
11	@MatrixParam Binds the parameter passed to the method to a HTTP matrix parameter in path.
12	@HeaderParam Binds the parameter passed to the method to a HTTP header.
13	@CookieParam  Binds the parameter passed to the method to a Cookie.
14	@FormParam Binds the parameter passed to the method to a form value.
15	@DefaultValue Assigns a default value to a parameter passed to the method.
16	@Context Context of the resource. For example, HTTPRequest as a context.
•	Note − We have used Jersey, a reference implementation of JAX-RS 2.0 by Oracle, in the RESTful Web Services - First Application and RESTful Web Services - Methods chapters.

